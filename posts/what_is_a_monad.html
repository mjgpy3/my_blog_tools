<p>Being a hobbyist Haskell programmer, I have heard the term &quot;monad&quot; a <em>lot</em>. In my experience playing with Haskell I have used monads plenty of times, however, it was not until recently that I have come to a digestible understanding of what they really are.</p>

<h1>Think Method Chaining</h1>

<p>Some of the prominent phrases which I hear being used to describe monads are &quot;they&#39;re ways to fake state&quot; and &quot;they are really just a form of method chaining.&quot; Although, in my (perhaps nieve) understanding of monads, both of these statements are true, the latter has been far more <em>useful</em> in helping me arrive at a useful understanding of &quot;the m word.&quot; So I encourage anyone who may be struggling with the definition of a monad to do the same: <em>think method chaining</em>.</p>

<h1>Method Chaining You Say?</h1>

<p>Yes method chaining. In the object oriented world this may mean something like this:
<pre class="prettyprint">
someObject.someMethod(1)
          .otherMethod(&quot;Pizza&quot;)
          .finalMethod()
</pre>
So, in OOP, the objects returned by each of these methods would encapsulate state. Now, in Haskell, there is not really a concept of state, things are what they are. The sequential mutilation of objects is not something Haskell supports naturally, so it uses the monad as a slick way to sort of &quot;fake state.&quot;</p>

<h1>What It Looks Like</h1>

<p><em>Disclaimer: this is my current understand of Haskellian monads, and not the similar but slightly different, mathematically definition of monads</em></p>

<p>To build a monad, two main functions are necessary as well as a monadic type. First I&#39;ll discuss a monadic type.</p>

<h1>Monadic Type</h1>

<p>A monad&#39;s type can be whatever it needs to be. Perhaps one of the most famous ones in the Haskell world it the <code class="prettyprint">Maybe</code> monad, which is defined simply as:
<pre class="prettyprint">
data Maybe a = Nothing | Just a
</pre>
<code class="prettyprint">Maybe</code> is one of the most beautiful aspects of Haskell. It is very similar to <code class="prettyprint">null</code> or <code class="prettyprint">nil</code> in other languages, but what makes it different is the fact that (as I understand it) in Haskell&#39;s pure, functional model, <code class="prettyprint">Maybe</code> cannot go unhandled or pop up in unexpected places. In my mind, it is a kind of a neat and precise example of a monadic type.</p>

<h1>The <code class="prettyprint">return</code> Function</h1>

<p>Another thing a monad needs is a <code class="prettyprint">return</code> function whose signature looks like:
<pre class="prettyprint">
return :: a -&gt; m a
</pre>
<code class="prettyprint">return</code> is simply a function whose purpose is to construct the monadic type. Pretty simple, eh? So for <code class="prettyprint">Maybe</code>, this might be as simple as:
<pre class="prettyprint">
return n = Just n
</pre></p>

<h1>The Bind Function</h1>

<p>The other function needed by a monad, the function that truly brings out the magic, is the bind function which is usually denoted as <code class="prettyprint">(&gt;&gt;=)</code> in the Haskell world. In the OOP example above, the bind function is kind of like the periods in between the different calls, but oh so much more magical. Bind&#39;s signature looks like:
<pre class="prettyprint">
(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b
</pre>
So, let&#39;s break this down.</p>

<p>The first thing that bind takes is a monadic type. So, this could be something as simple as <code class="prettyprint">Just 5</code> or whatever monadic type you are operating on. The second parameter is a function that takes the type boxed by the first parameter (the monadic type) and returns a monadic type boxing <code class="prettyprint">b</code> (which could be the same type as <code class="prettyprint">a</code> but by no means <em>must</em> be). In the end, bind returns another monadic type, as returned by the middle parameter.</p>

<p>All in all, this seems like a lot to swallow, and, uh, what does this have to do with method chaining or our <code class="prettyprint">return</code> function?</p>

<p>Remember, bind is really one of those strange infix operators, so if I may make some simplifications, it kind of looks like:
<pre class="prettyprint">
a thing &gt;&gt;= function that returns another thing
</pre>
In this simplification, &quot;thing&quot; is substituted for &quot;monadic type&quot; to make bind easier to swallow. The point is, all this whole mess does is return another monadic type! So, there&#39;s nothing keeping me from implementing another bind operator (or reusing the same one, if applicable) like such:
<pre class="prettyprint">
a thing &gt;&gt;= function that returns another thing &gt;&gt;= function that returns yet another thing ...
</pre>
See what I mean about this being like the &quot;period between&quot; in that above OOP example? All bind really does is take some value (wrapped in a monad) and apply some function to it, and re-wrap the output!</p>

<p><code class="prettyprint">return</code> is pretty cool because a lot of the time it comes at the end of all the binding (wow, a return at the end? Sounds like some other paradigms out there). <code class="prettyprint">return</code> is really the end game, the termination of the &quot;chaining.&quot;</p>

<h1>Parting Words</h1>

<p>In conclusion, I hope I have shed some light on what can be a very difficult topic to understand. If you would like to learn more, the Haskell community has a <a href="http://www.haskell.org/haskellwiki/All_About_Monads">great article on monads</a> also there are some really awesome answers to the question of &quot;what is a monad&quot; on <a href="http://stackoverflow.com/questions/44965/what-is-a-monad">SO</a>.</p>
